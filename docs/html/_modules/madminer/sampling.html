
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>madminer.sampling &#8212; MadMiner 0.1.1 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for madminer.sampling</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">six</span>

<span class="kn">from</span> <span class="nn">madminer.utils.interfaces.hdf5</span> <span class="k">import</span> <span class="n">load_madminer_settings</span><span class="p">,</span> <span class="n">madminer_event_loader</span>
<span class="kn">from</span> <span class="nn">madminer.utils.interfaces.hdf5</span> <span class="k">import</span> <span class="n">save_preformatted_events_to_madminer_file</span>
<span class="kn">from</span> <span class="nn">madminer.utils.analysis</span> <span class="k">import</span> <span class="n">get_theta_value</span><span class="p">,</span> <span class="n">get_theta_benchmark_matrix</span><span class="p">,</span> <span class="n">get_dtheta_benchmark_matrix</span>
<span class="kn">from</span> <span class="nn">madminer.utils.analysis</span> <span class="k">import</span> <span class="n">extract_augmented_data</span><span class="p">,</span> <span class="n">parse_theta</span>
<span class="kn">from</span> <span class="nn">madminer.morphing</span> <span class="k">import</span> <span class="n">Morpher</span>
<span class="kn">from</span> <span class="nn">madminer.utils.various</span> <span class="k">import</span> <span class="n">general_init</span><span class="p">,</span> <span class="n">format_benchmark</span><span class="p">,</span> <span class="n">create_missing_folders</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">,</span> <span class="n">balance_thetas</span>


<div class="viewcode-block" id="combine_and_shuffle"><a class="viewcode-back" href="../../madminer.sampling.html#madminer.sampling.combine_and_shuffle">[docs]</a><span class="k">def</span> <span class="nf">combine_and_shuffle</span><span class="p">(</span><span class="n">input_filenames</span><span class="p">,</span> <span class="n">output_filename</span><span class="p">,</span> <span class="n">overwrite_existing_file</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combines multiple MadMiner files into one, and shuffles the order of the events.</span>

<span class="sd">    Note that this function assumes that all samples are generated with the same setup, including identical benchmarks</span>
<span class="sd">    (and thus morphing setup). If it is used with samples with different settings, there will be wrong results!</span>
<span class="sd">    There are no explicit cross checks in place yet!</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_filenames : list of str</span>
<span class="sd">        List of paths to the input MadMiner files.</span>

<span class="sd">    output_filename : str</span>
<span class="sd">        Path to the combined MadMiner file.</span>

<span class="sd">    overwrite_existing_file : bool, optional</span>
<span class="sd">        If True and if the output file exists, it is overwritten. Default value: True.</span>

<span class="sd">    debug : bool, optional</span>
<span class="sd">        If True, additional detailed debugging output is printed. Default value: False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        None</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">general_init</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_filenames</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;Careful: this tool assumes that all samples are generated with the same setup, including&quot;</span>
            <span class="s2">&quot; identical benchmarks (and thus morphing setup). If it is used with samples with different&quot;</span>
            <span class="s2">&quot; settings, there will be wrong results! There are no explicit cross checks in place yet.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Copy first file to output_filename</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Copying setup from </span><span class="si">%s</span><span class="s2"> to </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">input_filenames</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">output_filename</span><span class="p">)</span>

    <span class="c1"># TODO: More memory efficient strategy</span>

    <span class="c1"># Load events</span>
    <span class="n">all_observations</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">all_weights</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">filename</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">input_filenames</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Loading samples from file </span><span class="si">%s</span><span class="s2"> / </span><span class="si">%s</span><span class="s2"> at </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_filenames</span><span class="p">),</span> <span class="n">filename</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">observations</span><span class="p">,</span> <span class="n">weights</span> <span class="ow">in</span> <span class="n">madminer_event_loader</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">all_observations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">all_observations</span> <span class="o">=</span> <span class="n">observations</span>
                <span class="n">all_weights</span> <span class="o">=</span> <span class="n">weights</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_observations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">all_observations</span><span class="p">,</span> <span class="n">observations</span><span class="p">))</span>
                <span class="n">all_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">all_weights</span><span class="p">,</span> <span class="n">weights</span><span class="p">))</span>

    <span class="c1"># Shuffle</span>
    <span class="n">all_observations</span><span class="p">,</span> <span class="n">all_weights</span> <span class="o">=</span> <span class="n">shuffle</span><span class="p">(</span><span class="n">all_observations</span><span class="p">,</span> <span class="n">all_weights</span><span class="p">)</span>

    <span class="c1"># Save result</span>
    <span class="n">save_preformatted_events_to_madminer_file</span><span class="p">(</span>
        <span class="n">filename</span><span class="o">=</span><span class="n">output_filename</span><span class="p">,</span>
        <span class="n">observations</span><span class="o">=</span><span class="n">all_observations</span><span class="p">,</span>
        <span class="n">weights</span><span class="o">=</span><span class="n">all_weights</span><span class="p">,</span>
        <span class="n">copy_setup_from</span><span class="o">=</span><span class="n">input_filenames</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">overwrite_existing_samples</span><span class="o">=</span><span class="n">overwrite_existing_file</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="constant_benchmark_theta"><a class="viewcode-back" href="../../madminer.sampling.html#madminer.sampling.constant_benchmark_theta">[docs]</a><span class="k">def</span> <span class="nf">constant_benchmark_theta</span><span class="p">(</span><span class="n">benchmark_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility function to be used as input to various SampleAugmenter functions, specifying a single parameter benchmark.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    benchmark_name : str</span>
<span class="sd">        Name of the benchmark (as in `madminer.core.MadMiner.add_benchmark`)</span>
<span class="sd">        </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output : tuple</span>
<span class="sd">        Input to various SampleAugmenter functions</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;benchmark&quot;</span><span class="p">,</span> <span class="n">benchmark_name</span></div>


<div class="viewcode-block" id="multiple_benchmark_thetas"><a class="viewcode-back" href="../../madminer.sampling.html#madminer.sampling.multiple_benchmark_thetas">[docs]</a><span class="k">def</span> <span class="nf">multiple_benchmark_thetas</span><span class="p">(</span><span class="n">benchmark_names</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility function to be used as input to various SampleAugmenter functions, specifying multiple parameter benchmarks.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    benchmark_names : list of str</span>
<span class="sd">        List of names of the benchmarks (as in `madminer.core.MadMiner.add_benchmark`)</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output : tuple</span>
<span class="sd">        Input to various SampleAugmenter functions</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;benchmarks&quot;</span><span class="p">,</span> <span class="n">benchmark_names</span></div>


<div class="viewcode-block" id="constant_morphing_theta"><a class="viewcode-back" href="../../madminer.sampling.html#madminer.sampling.constant_morphing_theta">[docs]</a><span class="k">def</span> <span class="nf">constant_morphing_theta</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility function to be used as input to various SampleAugmenter functions, specifying a single parameter point theta</span>
<span class="sd">    in a morphing setup.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    theta : ndarray or list</span>
<span class="sd">        Parameter point with shape `(n_parameters,)`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output : tuple</span>
<span class="sd">        Input to various SampleAugmenter functions</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;theta&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span></div>


<div class="viewcode-block" id="multiple_morphing_thetas"><a class="viewcode-back" href="../../madminer.sampling.html#madminer.sampling.multiple_morphing_thetas">[docs]</a><span class="k">def</span> <span class="nf">multiple_morphing_thetas</span><span class="p">(</span><span class="n">thetas</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility function to be used as input to various SampleAugmenter functions, specifying multiple parameter points</span>
<span class="sd">    theta in a morphing setup.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    thetas : ndarray or list of lists or list of ndarrays</span>
<span class="sd">        Parameter points with shape `(n_thetas, n_parameters)`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output : tuple</span>
<span class="sd">        Input to various SampleAugmenter functions</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;thetas&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="n">thetas</span><span class="p">]</span></div>


<div class="viewcode-block" id="random_morphing_thetas"><a class="viewcode-back" href="../../madminer.sampling.html#madminer.sampling.random_morphing_thetas">[docs]</a><span class="k">def</span> <span class="nf">random_morphing_thetas</span><span class="p">(</span><span class="n">n_thetas</span><span class="p">,</span> <span class="n">priors</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility function to be used as input to various SampleAugmenter functions, specifying random parameter points</span>
<span class="sd">    sampled from a prior in a morphing setup.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_thetas : int</span>
<span class="sd">        Number of parameter points to be sampled</span>

<span class="sd">    priors : list of tuples</span>
<span class="sd">        Priors for each parameter is characterized by a tuple of the form `(prior_shape, prior_param_0, prior_param_1)`.</span>
<span class="sd">        Currently, the supported prior_shapes are `flat`, in which case the two other parameters are the lower and upper</span>
<span class="sd">        bound of the flat prior, and `gaussian`, in which case they are the mean and standard deviation of a Gaussian.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output : tuple</span>
<span class="sd">        Input to various SampleAugmenter functions</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;random&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">n_thetas</span><span class="p">,</span> <span class="n">priors</span><span class="p">)</span></div>


<div class="viewcode-block" id="SampleAugmenter"><a class="viewcode-back" href="../../madminer.sampling.html#madminer.sampling.SampleAugmenter">[docs]</a><span class="k">class</span> <span class="nc">SampleAugmenter</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sampling and data augmentation.</span>

<span class="sd">    After the generated events have been analyzed and the observables and weights have been saved into a MadMiner file,</span>
<span class="sd">    for instance with `madminer.delphes.DelphesProcessor` or `madminer.lhe.LHEProcessor`, the next step is typically</span>
<span class="sd">    the generation of training and evaluation data for the machine learning algorithms. This generally involves two</span>
<span class="sd">    (related) tasks: unweighting, i.e. the creation of samples that do not carry individual weights but follow some</span>
<span class="sd">    distribution, and the extraction of the joint likelihood ratio and / or joint score (the &quot;augmented data&quot;).</span>

<span class="sd">    After inializing `SampleAugmenter` with the filename of a MadMiner file, this is done with a single function call.</span>
<span class="sd">    Depending on the downstream inference algorithm, there are different possibilities:</span>

<span class="sd">    * `SampleAugmenter.extract_samples_train_plain()` creates plain training samples without augmented data.</span>
<span class="sd">    * `SampleAugmenter.extract_samples_train_local()` creates training samples for local methods based on the score,</span>
<span class="sd">      such as SALLY and SALLINO.</span>
<span class="sd">    * `SampleAugmenter.extract_samples_train_global()` creates training samples for non-local methods based on density</span>
<span class="sd">      estimation and the score, such as SCANDAL.</span>
<span class="sd">    * `SampleAugmenter.extract_samples_train_ratio()` creates training samples for non-local, ratio-based methods</span>
<span class="sd">      like RASCAL or ALICE.</span>
<span class="sd">    * `SampleAugmenter.extract_samples_train_more_ratios()` does the same, but can extract joint ratios and scores</span>
<span class="sd">      at more parameter points. This additional information  can be used efficiently in the setup with a &quot;doubly</span>
<span class="sd">      parameterized&quot; likelihood ratio estimator that models the dependence on both the numerator and denominator</span>
<span class="sd">      hypothesis.</span>
<span class="sd">    * `SampleAugmenter.extract_samples_test()` creates evaluation samples for all methods.</span>

<span class="sd">    Please see the tutorial for a walkthrough.</span>

<span class="sd">    For the curious, let us explain these steps in a little bit more detail (assuming a morphing setup):</span>

<span class="sd">    * The sample augmentation step starts from a set of events `(x_i, z_i)` together with corresponding weights for each</span>
<span class="sd">      morphing basis point `theta_b`, `p(x_i, z_i | theta_b)`.</span>
<span class="sd">    * Morphing: Assume we want to generate data sampled from a parameter point theta, which is not necessarily one of</span>
<span class="sd">      the basis points theta_b. Using the morphing structure, the event weights for p(x_i, z_i | theta) can be</span>
<span class="sd">      calculated. Note that the events (phase-space points) `(x_i, z_i)` are not changed, only their weights.</span>
<span class="sd">    * Unweighting: For the machine learning part, such a weighted event sample is not practical. Instead we aim for an</span>
<span class="sd">      unweighted one, in which events can appear multiple times. If the user request `N` events (which can be larger</span>
<span class="sd">      than the original number of events in the MadGraph runs), SampleAugmenter will draw `N` samples `(x_i, z_i)` from</span>
<span class="sd">      the discrete distribution `p(x_i, z_i | theta)`. In other words, it draws (with replacement) `N` of the original</span>
<span class="sd">      events from MadGraph, with probabilities given by the morphing setup before. This is similar to what</span>
<span class="sd">      `np.random.choice()` does.</span>
<span class="sd">    * Augmentation: For each of the drawn samples, the morphing setup can be used to calculate the joint likelihood</span>
<span class="sd">      ratio and / or the joint score (this depends on which SampleAugmenter function is called).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>
<span class="sd">        Path to MadMiner file (for instance the output of `madminer.delphes.DelphesProcessor.save()`).</span>

<span class="sd">    disable_morphing : bool, optional</span>
<span class="sd">        If True, the morphing setup is not loaded from the file. Default value: False.</span>

<span class="sd">    debug : bool, optional</span>
<span class="sd">        If True, additional detailed debugging output is printed. Default value: False.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">disable_morphing</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="n">general_init</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">madminer_filename</span> <span class="o">=</span> <span class="n">filename</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Loading data from </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

        <span class="c1"># Load data</span>
        <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">benchmarks</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">morphing_components</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">morphing_matrix</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">load_madminer_settings</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_parameters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Found </span><span class="si">%s</span><span class="s2"> parameters:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_parameters</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;   </span><span class="si">%s</span><span class="s2"> (LHA: </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">, maximal power in squared ME: </span><span class="si">%s</span><span class="s2">, range: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span>
                <span class="n">key</span><span class="p">,</span>
                <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">values</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">values</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
            <span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Found </span><span class="si">%s</span><span class="s2"> benchmarks:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">benchmarks</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">benchmarks</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;   </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">format_benchmark</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Found </span><span class="si">%s</span><span class="s2"> observables: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">),</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">))</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Found </span><span class="si">%s</span><span class="s2"> events&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">)</span>

        <span class="c1"># Morphing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">morpher</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">morphing_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">morphing_components</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">disable_morphing</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">morpher</span> <span class="o">=</span> <span class="n">Morpher</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">morpher</span><span class="o">.</span><span class="n">set_components</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">morphing_components</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">morpher</span><span class="o">.</span><span class="n">set_basis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">benchmarks</span><span class="p">,</span> <span class="n">morphing_matrix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">morphing_matrix</span><span class="p">)</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Found morphing setup with </span><span class="si">%s</span><span class="s2"> components&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">morphing_components</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Did not find morphing setup.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="SampleAugmenter.extract_samples_train_plain"><a class="viewcode-back" href="../../madminer.sampling.html#madminer.sampling.SampleAugmenter.extract_samples_train_plain">[docs]</a>    <span class="k">def</span> <span class="nf">extract_samples_train_plain</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">folder</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">test_split</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">switch_train_test_events</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts plain training samples `x ~ p(x|theta)` without any augmented data. This can be use for standard</span>
<span class="sd">        inference methods such as ABC, histograms of observables, or neural density estimation techniques. It can also</span>
<span class="sd">        be used to create validation or calibration samples.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta : tuple</span>
<span class="sd">            Tuple (type, value) that defines the parameter point or prior over parameter points for the</span>
<span class="sd">            sampling. Pass the output of the functions `constant_benchmark_theta()`, `multiple_benchmark_thetas()`,</span>
<span class="sd">            `constant_morphing_theta()`, `multiple_morphing_thetas()`, or `random_morphing_thetas()`.</span>

<span class="sd">        n_samples : int</span>
<span class="sd">            Total number of events to be drawn.</span>

<span class="sd">        folder : str</span>
<span class="sd">            Path to the folder where the resulting samples should be saved (ndarrays in .npy format).</span>

<span class="sd">        filename : str</span>
<span class="sd">            Filenames for the resulting samples. A prefix such as &#39;x&#39; or &#39;theta0&#39; as well as the extension</span>
<span class="sd">            &#39;.npy&#39; will be added automatically.</span>

<span class="sd">        test_split : float or None, optional</span>
<span class="sd">            Fraction of events reserved for the evaluation sample (that will not be used for any training samples).</span>
<span class="sd">            Default value: 0.5.</span>

<span class="sd">        switch_train_test_events : bool, optional</span>
<span class="sd">            If True, this function generates a training sample from the events normally reserved for test samples.</span>
<span class="sd">            Default value: False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        x : ndarray</span>
<span class="sd">            Observables with shape `(n_samples, n_observables)`. The same information is saved as a file in the given</span>
<span class="sd">            folder.</span>

<span class="sd">        theta : ndarray</span>
<span class="sd">            Parameter points used for sampling with shape `(n_samples, n_parameters)`. The same information is saved as</span>
<span class="sd">            a file in the given folder.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Extracting plain training sample. Sampling according to </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>

        <span class="n">create_missing_folders</span><span class="p">([</span><span class="n">folder</span><span class="p">])</span>

        <span class="c1"># Thetas</span>
        <span class="n">theta_types</span><span class="p">,</span> <span class="n">theta_values</span><span class="p">,</span> <span class="n">n_samples_per_theta</span> <span class="o">=</span> <span class="n">parse_theta</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">)</span>

        <span class="c1"># Train / test split</span>
        <span class="n">start_event</span><span class="p">,</span> <span class="n">end_event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_train_test_split</span><span class="p">(</span><span class="ow">not</span> <span class="n">switch_train_test_events</span><span class="p">,</span> <span class="n">test_split</span><span class="p">)</span>

        <span class="c1"># Start</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="p">(</span><span class="n">theta</span><span class="p">,)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_sample</span><span class="p">(</span>
            <span class="n">theta_sets_types</span><span class="o">=</span><span class="p">[</span><span class="n">theta_types</span><span class="p">],</span>
            <span class="n">theta_sets_values</span><span class="o">=</span><span class="p">[</span><span class="n">theta_values</span><span class="p">],</span>
            <span class="n">n_samples_per_theta</span><span class="o">=</span><span class="n">n_samples_per_theta</span><span class="p">,</span>
            <span class="n">start_event</span><span class="o">=</span><span class="n">start_event</span><span class="p">,</span>
            <span class="n">end_event</span><span class="o">=</span><span class="n">end_event</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Save data</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">folder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">folder</span> <span class="o">+</span> <span class="s2">&quot;/theta_&quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">folder</span> <span class="o">+</span> <span class="s2">&quot;/x_&quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">theta</span></div>

<div class="viewcode-block" id="SampleAugmenter.extract_samples_train_local"><a class="viewcode-back" href="../../madminer.sampling.html#madminer.sampling.SampleAugmenter.extract_samples_train_local">[docs]</a>    <span class="k">def</span> <span class="nf">extract_samples_train_local</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">folder</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">test_split</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">switch_train_test_events</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">log_message</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts training samples x ~ p(x|theta) as well as the joint score t(x, z|theta). This can be used for</span>
<span class="sd">        inference methods such as SALLY and SALLINO.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta : tuple</span>
<span class="sd">            Tuple (type, value) that defines the parameter point for the sampling. This is also where the score is</span>
<span class="sd">            evaluated. Pass the output of the functions `constant_benchmark_theta()` or `constant_morphing_theta()`.</span>

<span class="sd">        n_samples : int</span>
<span class="sd">            Total number of events to be drawn.</span>

<span class="sd">        folder : str</span>
<span class="sd">            Path to the folder where the resulting samples should be saved (ndarrays in .npy format).</span>

<span class="sd">        filename : str</span>
<span class="sd">            Filenames for the resulting samples. A prefix such as &#39;x&#39; or &#39;theta0&#39; as well as the extension</span>
<span class="sd">            &#39;.npy&#39; will be added automatically.</span>

<span class="sd">        test_split : float or None, optional</span>
<span class="sd">            Fraction of events reserved for the evaluation sample (that will not be used for any training samples).</span>
<span class="sd">            Default value: 0.5.</span>

<span class="sd">        switch_train_test_events : bool, optional</span>
<span class="sd">            If True, this function generates a training sample from the events normally reserved for test samples.</span>
<span class="sd">            Default value: False.</span>

<span class="sd">        log_message : bool, optional</span>
<span class="sd">            If True, logging output. This option is only designed for internal use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        x : ndarray</span>
<span class="sd">            Observables with shape `(n_samples, n_observables)`. The same information is saved as a file in the given</span>
<span class="sd">            folder.</span>

<span class="sd">        theta : ndarray</span>
<span class="sd">            Parameter points used for sampling (and  evaluation of the joint score) with shape</span>
<span class="sd">            `(n_samples, n_parameters)`. The same information is saved as a file in the given folder.</span>

<span class="sd">        t_xz : ndarray</span>
<span class="sd">            Joint score evaluated at theta with shape `(n_samples, n_parameters)`. The same information is saved as a</span>
<span class="sd">            file in the given folder.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">log_message</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Extracting training sample for local score regression. Sampling and score evaluation according to </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">theta</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">create_missing_folders</span><span class="p">([</span><span class="n">folder</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">morpher</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No morphing setup loaded. Cannot calculate score.&quot;</span><span class="p">)</span>

        <span class="c1"># Thetas</span>
        <span class="n">theta_types</span><span class="p">,</span> <span class="n">theta_values</span><span class="p">,</span> <span class="n">n_samples_per_theta</span> <span class="o">=</span> <span class="n">parse_theta</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">)</span>

        <span class="c1"># Augmented data (gold)</span>
        <span class="n">augmented_data_definitions</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;score&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>

        <span class="c1"># Train / test split</span>
        <span class="n">start_event</span><span class="p">,</span> <span class="n">end_event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_train_test_split</span><span class="p">(</span><span class="ow">not</span> <span class="n">switch_train_test_events</span><span class="p">,</span> <span class="n">test_split</span><span class="p">)</span>

        <span class="c1"># Start</span>
        <span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">t_xz</span><span class="p">,),</span> <span class="p">(</span><span class="n">theta</span><span class="p">,)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_sample</span><span class="p">(</span>
            <span class="n">theta_sets_types</span><span class="o">=</span><span class="p">[</span><span class="n">theta_types</span><span class="p">],</span>
            <span class="n">theta_sets_values</span><span class="o">=</span><span class="p">[</span><span class="n">theta_values</span><span class="p">],</span>
            <span class="n">n_samples_per_theta</span><span class="o">=</span><span class="n">n_samples_per_theta</span><span class="p">,</span>
            <span class="n">augmented_data_definitions</span><span class="o">=</span><span class="n">augmented_data_definitions</span><span class="p">,</span>
            <span class="n">start_event</span><span class="o">=</span><span class="n">start_event</span><span class="p">,</span>
            <span class="n">end_event</span><span class="o">=</span><span class="n">end_event</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Save data</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">folder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">folder</span> <span class="o">+</span> <span class="s2">&quot;/theta_&quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">folder</span> <span class="o">+</span> <span class="s2">&quot;/x_&quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">folder</span> <span class="o">+</span> <span class="s2">&quot;/t_xz_&quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="n">t_xz</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">t_xz</span></div>

<div class="viewcode-block" id="SampleAugmenter.extract_samples_train_global"><a class="viewcode-back" href="../../madminer.sampling.html#madminer.sampling.SampleAugmenter.extract_samples_train_global">[docs]</a>    <span class="k">def</span> <span class="nf">extract_samples_train_global</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">folder</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">test_split</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">switch_train_test_events</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts training samples x ~ p(x|theta) as well as the joint score t(x, z|theta), where theta is sampled</span>
<span class="sd">        from a prior. This can be used for inference methods such as SCANDAL.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta : tuple</span>
<span class="sd">            Tuple (type, value) that defines the numerator parameter point or prior over parameter points for the</span>
<span class="sd">            sampling. Pass the output of the functions `constant_benchmark_theta()`, `multiple_benchmark_thetas()`,</span>
<span class="sd">            `constant_morphing_theta()`, `multiple_morphing_thetas()`, or `random_morphing_thetas()`.</span>

<span class="sd">        n_samples : int</span>
<span class="sd">            Total number of events to be drawn.</span>

<span class="sd">        folder : str</span>
<span class="sd">            Path to the folder where the resulting samples should be saved (ndarrays in .npy format).</span>

<span class="sd">        filename : str</span>
<span class="sd">            Filenames for the resulting samples. A prefix such as &#39;x&#39; or &#39;theta0&#39; as well as the extension</span>
<span class="sd">            &#39;.npy&#39; will be added automatically.</span>

<span class="sd">        test_split : float or None, optional</span>
<span class="sd">            Fraction of events reserved for the evaluation sample (that will not be used for any training samples).</span>
<span class="sd">            Default value: 0.5.</span>

<span class="sd">        switch_train_test_events : bool, optional</span>
<span class="sd">            If True, this function generates a training sample from the events normally reserved for test samples.</span>
<span class="sd">            Default value: False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        x : ndarray</span>
<span class="sd">            Observables with shape `(n_samples, n_observables)`. The same information is saved as a file in the given</span>
<span class="sd">            folder.</span>

<span class="sd">        theta : ndarray</span>
<span class="sd">            Parameter points used for sampling (and  evaluation of the joint score) with shape</span>
<span class="sd">            `(n_samples, n_parameters)`. The same information is saved as a file in the given folder.</span>

<span class="sd">        t_xz : ndarray</span>
<span class="sd">            Joint score evaluated at theta with shape `(n_samples, n_parameters)`. The same information is saved as a</span>
<span class="sd">            file in the given folder.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Extracting training sample for non-local score-based methods. Sampling and score evaluation according &quot;</span>
            <span class="s2">&quot;to </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">theta</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_samples_train_local</span><span class="p">(</span>
            <span class="n">theta</span><span class="p">,</span>
            <span class="n">n_samples</span><span class="p">,</span>
            <span class="n">folder</span><span class="p">,</span>
            <span class="n">filename</span><span class="p">,</span>
            <span class="n">test_split</span><span class="o">=</span><span class="n">test_split</span><span class="p">,</span>
            <span class="n">switch_train_test_events</span><span class="o">=</span><span class="n">switch_train_test_events</span><span class="p">,</span>
            <span class="n">log_message</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="SampleAugmenter.extract_samples_train_ratio"><a class="viewcode-back" href="../../madminer.sampling.html#madminer.sampling.SampleAugmenter.extract_samples_train_ratio">[docs]</a>    <span class="k">def</span> <span class="nf">extract_samples_train_ratio</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">theta0</span><span class="p">,</span> <span class="n">theta1</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">folder</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">test_split</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">switch_train_test_events</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts training samples `x ~ p(x|theta0)` and `x ~ p(x|theta1)` together with the class label `y`, the joint</span>
<span class="sd">        likelihood ratio `r(x,z|theta0, theta1)`, and the joint score `t(x,z|theta0)`. This information can be used in</span>
<span class="sd">        inference methods such as CARL, ROLR, CASCAL, and RASCAL.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta0 : tuple</span>
<span class="sd">            Tuple (type, value) that defines the numerator parameter point or prior over parameter points for the</span>
<span class="sd">            sampling. Pass the output of the functions `constant_benchmark_theta()`, `multiple_benchmark_thetas()`,</span>
<span class="sd">            `constant_morphing_theta()`, `multiple_morphing_thetas()`, or `random_morphing_thetas()`.</span>

<span class="sd">        theta1 : tuple</span>
<span class="sd">            Tuple (type, value) that defines the denominator parameter point or prior over parameter points for the</span>
<span class="sd">            sampling. Pass the output of the functions `constant_benchmark_theta()`, `multiple_benchmark_thetas()`,</span>
<span class="sd">            `constant_morphing_theta()`, `multiple_morphing_thetas()`, or `random_morphing_thetas()`.</span>

<span class="sd">        n_samples : int</span>
<span class="sd">            Total number of events to be drawn.</span>

<span class="sd">        folder : str</span>
<span class="sd">            Path to the folder where the resulting samples should be saved (ndarrays in .npy format).</span>

<span class="sd">        filename : str</span>
<span class="sd">            Filenames for the resulting samples. A prefix such as &#39;x&#39; or &#39;theta0&#39; as well as the extension</span>
<span class="sd">            &#39;.npy&#39; will be added automatically.</span>

<span class="sd">        test_split : float or None, optional</span>
<span class="sd">            Fraction of events reserved for the evaluation sample (that will not be used for any training samples).</span>
<span class="sd">            Default value: 0.5.</span>

<span class="sd">        switch_train_test_events : bool, optional</span>
<span class="sd">            If True, this function generates a training sample from the events normally reserved for test samples.</span>
<span class="sd">            Default value: False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        x : ndarray</span>
<span class="sd">            Observables with shape `(n_samples, n_observables)`. The same information is saved as a file in the given</span>
<span class="sd">            folder.</span>

<span class="sd">        theta0 : ndarray</span>
<span class="sd">            Numerator parameter points with shape `(n_samples, n_parameters)`. The same information is saved as</span>
<span class="sd">            a file in the given folder.</span>

<span class="sd">        theta1 : ndarray</span>
<span class="sd">            Denominator parameter points with shape `(n_samples, n_parameters)`. The same information is saved as</span>
<span class="sd">            a file in the given folder.</span>

<span class="sd">        y : ndarray</span>
<span class="sd">            Class label with shape `(n_samples, n_parameters)`. `y=0` (`1`) for events sample from the numerator</span>
<span class="sd">            (denominator) hypothesis. The same information is saved as a file in the given folder.</span>

<span class="sd">        r_xz : ndarray</span>
<span class="sd">            Joint likelihood ratio with shape `(n_samples,)`. The same information is saved as a file in the given</span>
<span class="sd">            folder.</span>

<span class="sd">        t_xz : ndarray</span>
<span class="sd">            Joint score evaluated at theta0 with shape `(n_samples, n_parameters)`. The same information is saved as a</span>
<span class="sd">            file in the given folder.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Extracting training sample for ratio-based methods. Numerator hypothesis: </span><span class="si">%s</span><span class="s2">, denominator &quot;</span>
            <span class="s2">&quot;hypothesis: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">theta0</span><span class="p">,</span>
            <span class="n">theta1</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">morpher</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No morphing setup loaded. Cannot calculate score.&quot;</span><span class="p">)</span>

        <span class="n">create_missing_folders</span><span class="p">([</span><span class="n">folder</span><span class="p">])</span>

        <span class="c1"># Augmented data (gold)</span>
        <span class="n">augmented_data_definitions</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;ratio&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;score&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>

        <span class="c1"># Train / test split</span>
        <span class="n">start_event</span><span class="p">,</span> <span class="n">end_event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_train_test_split</span><span class="p">(</span><span class="ow">not</span> <span class="n">switch_train_test_events</span><span class="p">,</span> <span class="n">test_split</span><span class="p">)</span>

        <span class="c1"># Thetas for theta0 sampling</span>
        <span class="n">theta0_types</span><span class="p">,</span> <span class="n">theta0_values</span><span class="p">,</span> <span class="n">n_samples_per_theta0</span> <span class="o">=</span> <span class="n">parse_theta</span><span class="p">(</span><span class="n">theta0</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">theta1_types</span><span class="p">,</span> <span class="n">theta1_values</span><span class="p">,</span> <span class="n">n_samples_per_theta1</span> <span class="o">=</span> <span class="n">parse_theta</span><span class="p">(</span><span class="n">theta1</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">n_samples_per_theta</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_samples_per_theta0</span><span class="p">,</span> <span class="n">n_samples_per_theta1</span><span class="p">)</span>

        <span class="c1"># Start for theta0</span>
        <span class="n">x0</span><span class="p">,</span> <span class="p">(</span><span class="n">r_xz0</span><span class="p">,</span> <span class="n">t_xz0</span><span class="p">),</span> <span class="p">(</span><span class="n">theta0_0</span><span class="p">,</span> <span class="n">theta1_0</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_sample</span><span class="p">(</span>
            <span class="n">theta_sets_types</span><span class="o">=</span><span class="p">[</span><span class="n">theta0_types</span><span class="p">,</span> <span class="n">theta1_types</span><span class="p">],</span>
            <span class="n">theta_sets_values</span><span class="o">=</span><span class="p">[</span><span class="n">theta0_values</span><span class="p">,</span> <span class="n">theta1_values</span><span class="p">],</span>
            <span class="n">sampling_theta_index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">n_samples_per_theta</span><span class="o">=</span><span class="n">n_samples_per_theta</span><span class="p">,</span>
            <span class="n">augmented_data_definitions</span><span class="o">=</span><span class="n">augmented_data_definitions</span><span class="p">,</span>
            <span class="n">start_event</span><span class="o">=</span><span class="n">start_event</span><span class="p">,</span>
            <span class="n">end_event</span><span class="o">=</span><span class="n">end_event</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Thetas for theta1 sampling (could be different if num or denom are random)</span>
        <span class="n">theta0_types</span><span class="p">,</span> <span class="n">theta0_values</span><span class="p">,</span> <span class="n">n_samples_per_theta0</span> <span class="o">=</span> <span class="n">parse_theta</span><span class="p">(</span><span class="n">theta0</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">theta1_types</span><span class="p">,</span> <span class="n">theta1_values</span><span class="p">,</span> <span class="n">n_samples_per_theta1</span> <span class="o">=</span> <span class="n">parse_theta</span><span class="p">(</span><span class="n">theta1</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">n_samples_per_theta</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_samples_per_theta0</span><span class="p">,</span> <span class="n">n_samples_per_theta1</span><span class="p">)</span>

        <span class="c1"># Start for theta1</span>
        <span class="n">x1</span><span class="p">,</span> <span class="p">(</span><span class="n">r_xz1</span><span class="p">,</span> <span class="n">t_xz1</span><span class="p">),</span> <span class="p">(</span><span class="n">theta0_1</span><span class="p">,</span> <span class="n">theta1_1</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_sample</span><span class="p">(</span>
            <span class="n">theta_sets_types</span><span class="o">=</span><span class="p">[</span><span class="n">theta0_types</span><span class="p">,</span> <span class="n">theta1_types</span><span class="p">],</span>
            <span class="n">theta_sets_values</span><span class="o">=</span><span class="p">[</span><span class="n">theta0_values</span><span class="p">,</span> <span class="n">theta1_values</span><span class="p">],</span>
            <span class="n">sampling_theta_index</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">n_samples_per_theta</span><span class="o">=</span><span class="n">n_samples_per_theta</span><span class="p">,</span>
            <span class="n">augmented_data_definitions</span><span class="o">=</span><span class="n">augmented_data_definitions</span><span class="p">,</span>
            <span class="n">start_event</span><span class="o">=</span><span class="n">start_event</span><span class="p">,</span>
            <span class="n">end_event</span><span class="o">=</span><span class="n">end_event</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Combine</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">])</span>
        <span class="n">r_xz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">r_xz0</span><span class="p">,</span> <span class="n">r_xz1</span><span class="p">])</span>
        <span class="n">t_xz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">t_xz0</span><span class="p">,</span> <span class="n">t_xz1</span><span class="p">])</span>
        <span class="n">theta0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">theta0_0</span><span class="p">,</span> <span class="n">theta0_1</span><span class="p">])</span>
        <span class="n">theta1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">theta1_0</span><span class="p">,</span> <span class="n">theta1_1</span><span class="p">])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">y</span><span class="p">[</span><span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># Shuffle</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">r_xz</span><span class="p">,</span> <span class="n">t_xz</span><span class="p">,</span> <span class="n">theta0</span><span class="p">,</span> <span class="n">theta1</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">shuffle</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">r_xz</span><span class="p">,</span> <span class="n">t_xz</span><span class="p">,</span> <span class="n">theta0</span><span class="p">,</span> <span class="n">theta1</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="c1"># y shape</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Save data</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">folder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">folder</span> <span class="o">+</span> <span class="s2">&quot;/theta0_&quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="n">theta0</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">folder</span> <span class="o">+</span> <span class="s2">&quot;/theta1_&quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="n">theta1</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">folder</span> <span class="o">+</span> <span class="s2">&quot;/x_&quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">folder</span> <span class="o">+</span> <span class="s2">&quot;/y_&quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">folder</span> <span class="o">+</span> <span class="s2">&quot;/r_xz_&quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="n">r_xz</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">folder</span> <span class="o">+</span> <span class="s2">&quot;/t_xz_&quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="n">t_xz</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">theta0</span><span class="p">,</span> <span class="n">theta1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">r_xz</span><span class="p">,</span> <span class="n">t_xz</span></div>

<div class="viewcode-block" id="SampleAugmenter.extract_samples_train_more_ratios"><a class="viewcode-back" href="../../madminer.sampling.html#madminer.sampling.SampleAugmenter.extract_samples_train_more_ratios">[docs]</a>    <span class="k">def</span> <span class="nf">extract_samples_train_more_ratios</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">theta0</span><span class="p">,</span>
        <span class="n">theta1</span><span class="p">,</span>
        <span class="n">n_samples</span><span class="p">,</span>
        <span class="n">folder</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">,</span>
        <span class="n">additional_thetas</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">test_split</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">switch_train_test_events</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts training samples `x ~ p(x|theta0)` and `x ~ p(x|theta1)` together with the class label `y`, the joint</span>
<span class="sd">        likelihood ratio `r(x,z|theta0, theta1)`, and the joint score `t(x,z|theta0)`. This information can be used in</span>
<span class="sd">        inference methods such as CARL, ROLR, CASCAL, and RASCAL.</span>

<span class="sd">        With the keyword `additional_thetas`, this function allows to extract joint ratios and scores</span>
<span class="sd">        at more parameter points than just `theta0` and `theta1`. This additional information can be used efficiently</span>
<span class="sd">        in the setup with a &quot;doubly parameterized&quot; likelihood ratio estimator that models the dependence on both the</span>
<span class="sd">        numerator and denominator hypothesis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta0 :</span>
<span class="sd">            Tuple (type, value) that defines the numerator parameter point or prior over parameter points for the</span>
<span class="sd">            sampling. Pass the output of the functions `constant_benchmark_theta()`, `multiple_benchmark_thetas()`,</span>
<span class="sd">            `constant_morphing_theta()`, `multiple_morphing_thetas()`, or `random_morphing_thetas()`.</span>

<span class="sd">        theta1 :</span>
<span class="sd">            Tuple (type, value) that defines the denominator parameter point or prior over parameter points for the</span>
<span class="sd">            sampling. Pass the output of the functions `constant_benchmark_theta()`, `multiple_benchmark_thetas()`,</span>
<span class="sd">            `constant_morphing_theta()`, `multiple_morphing_thetas()`, or `random_morphing_thetas()`.</span>

<span class="sd">        n_samples : int</span>
<span class="sd">            Total number of events to be drawn.</span>

<span class="sd">        folder : str</span>
<span class="sd">            Path to the folder where the resulting samples should be saved (ndarrays in .npy format).</span>

<span class="sd">        filename : str</span>
<span class="sd">            Filenames for the resulting samples. A prefix such as &#39;x&#39; or &#39;theta0&#39; as well as the extension</span>
<span class="sd">            &#39;.npy&#39; will be added automatically.</span>

<span class="sd">        additional_thetas : list of tuple or None</span>
<span class="sd">            list of tuples `(type, value)` that defines additional theta points at which ratio and score are evaluated,</span>
<span class="sd">            and which are then used to create additional training data points. These can be efficiently used only in</span>
<span class="sd">            the &quot;doubly parameterized&quot; setup where a likelihood ratio estimator models the dependence of the likelihood</span>
<span class="sd">            ratio on both the numerator and denominator hypothesis. Pass the output of  the helper functions</span>
<span class="sd">            `constant_benchmark_theta()`, `multiple_benchmark_thetas()`, `constant_morphing_theta()`,</span>
<span class="sd">            `multiple_morphing_thetas()`, or `random_morphing_thetas()`. Default value: None.</span>

<span class="sd">        test_split : float or None, optional</span>
<span class="sd">            Fraction of events reserved for the evaluation sample (that will not be used for any training samples).</span>
<span class="sd">            Default value: 0.5.</span>

<span class="sd">        switch_train_test_events : bool, optional</span>
<span class="sd">            If True, this function generates a training sample from the events normally reserved for test samples.</span>
<span class="sd">            Default value: False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        x : ndarray</span>
<span class="sd">            Observables with shape `(n_samples, n_observables)`. The same information is saved as a file in the given</span>
<span class="sd">            folder.</span>

<span class="sd">        theta0 : ndarray</span>
<span class="sd">            Numerator parameter points with shape `(n_samples, n_parameters)`. The same information is saved as</span>
<span class="sd">            a file in the given folder.</span>

<span class="sd">        theta1 : ndarray</span>
<span class="sd">            Denominator parameter points with shape `(n_samples, n_parameters)`. The same information is saved as</span>
<span class="sd">            a file in the given folder.</span>

<span class="sd">        y : ndarray</span>
<span class="sd">            Class label with shape `(n_samples, n_parameters)`. `y=0` (`1`) for events sample from the numerator</span>
<span class="sd">            (denominator) hypothesis. The same information is saved as a file in the given folder.</span>

<span class="sd">        r_xz : ndarray</span>
<span class="sd">            Joint likelihood ratio with shape `(n_samples,)`. The same information is saved as a file in the given</span>
<span class="sd">            folder.</span>

<span class="sd">        t_xz : ndarray</span>
<span class="sd">            Joint score evaluated at theta0 with shape `(n_samples, n_parameters)`. The same information is saved as a</span>
<span class="sd">            file in the given folder.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Extracting training sample for ratio-based methods. Numerator hypothesis: </span><span class="si">%s</span><span class="s2">, denominator &quot;</span>
            <span class="s2">&quot;hypothesis: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">theta0</span><span class="p">,</span>
            <span class="n">theta1</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">morpher</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No morphing setup loaded. Cannot calculate score.&quot;</span><span class="p">)</span>

        <span class="n">create_missing_folders</span><span class="p">([</span><span class="n">folder</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">additional_thetas</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">additional_thetas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">n_additional_thetas</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">additional_thetas</span><span class="p">)</span>

        <span class="c1"># Augmented data (gold)</span>
        <span class="n">augmented_data_definitions_0</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;ratio&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;score&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;score&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">augmented_data_definitions_1</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;ratio&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;score&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;score&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_additional_thetas</span><span class="p">):</span>
            <span class="n">augmented_data_definitions_0</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;ratio&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">augmented_data_definitions_0</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;score&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">augmented_data_definitions_1</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;ratio&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">augmented_data_definitions_1</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;score&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># Train / test split</span>
        <span class="n">start_event</span><span class="p">,</span> <span class="n">end_event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_train_test_split</span><span class="p">(</span><span class="ow">not</span> <span class="n">switch_train_test_events</span><span class="p">,</span> <span class="n">test_split</span><span class="p">)</span>

        <span class="c1"># Parse thetas for theta0 sampling</span>
        <span class="n">theta_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">theta_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">n_samples_per_theta</span> <span class="o">=</span> <span class="mi">1000000</span>

        <span class="n">theta0_types</span><span class="p">,</span> <span class="n">theta0_values</span><span class="p">,</span> <span class="n">this_n_samples</span> <span class="o">=</span> <span class="n">parse_theta</span><span class="p">(</span><span class="n">theta0</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">theta_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theta0_types</span><span class="p">)</span>
        <span class="n">theta_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theta0_values</span><span class="p">)</span>
        <span class="n">n_samples_per_theta</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">this_n_samples</span><span class="p">,</span> <span class="n">n_samples_per_theta</span><span class="p">)</span>

        <span class="n">theta1_types</span><span class="p">,</span> <span class="n">theta1_values</span><span class="p">,</span> <span class="n">this_n_samples</span> <span class="o">=</span> <span class="n">parse_theta</span><span class="p">(</span><span class="n">theta1</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">theta_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theta1_types</span><span class="p">)</span>
        <span class="n">theta_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theta1_values</span><span class="p">)</span>
        <span class="n">n_samples_per_theta</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">this_n_samples</span><span class="p">,</span> <span class="n">n_samples_per_theta</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">additional_theta</span> <span class="ow">in</span> <span class="n">additional_thetas</span><span class="p">:</span>
            <span class="n">additional_theta_types</span><span class="p">,</span> <span class="n">additional_theta_values</span><span class="p">,</span> <span class="n">this_n_samples</span> <span class="o">=</span> <span class="n">parse_theta</span><span class="p">(</span>
                <span class="n">additional_theta</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="p">)</span>
            <span class="n">theta_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">additional_theta_types</span><span class="p">)</span>
            <span class="n">theta_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">additional_theta_values</span><span class="p">)</span>
            <span class="n">n_samples_per_theta</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">this_n_samples</span><span class="p">,</span> <span class="n">n_samples_per_theta</span><span class="p">)</span>

        <span class="c1"># Start for theta0</span>
        <span class="n">x_0</span><span class="p">,</span> <span class="n">augmented_data_0</span><span class="p">,</span> <span class="n">thetas_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_sample</span><span class="p">(</span>
            <span class="n">theta_sets_types</span><span class="o">=</span><span class="n">theta_types</span><span class="p">,</span>
            <span class="n">theta_sets_values</span><span class="o">=</span><span class="n">theta_values</span><span class="p">,</span>
            <span class="n">n_samples_per_theta</span><span class="o">=</span><span class="n">n_samples_per_theta</span><span class="p">,</span>
            <span class="n">augmented_data_definitions</span><span class="o">=</span><span class="n">augmented_data_definitions_0</span><span class="p">,</span>
            <span class="n">sampling_theta_index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">start_event</span><span class="o">=</span><span class="n">start_event</span><span class="p">,</span>
            <span class="n">end_event</span><span class="o">=</span><span class="n">end_event</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">n_actual_samples</span> <span class="o">=</span> <span class="n">x_0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Analyse theta values from theta0 run</span>
        <span class="n">theta0_0</span> <span class="o">=</span> <span class="n">thetas_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">theta1_0</span> <span class="o">=</span> <span class="n">thetas_0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">thetas_eval</span> <span class="o">=</span> <span class="n">thetas_0</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>

        <span class="c1"># Analyse augmented data from theta0 run</span>
        <span class="n">r_xz_0</span> <span class="o">=</span> <span class="n">augmented_data_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">t_xz0_0</span> <span class="o">=</span> <span class="n">augmented_data_0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">t_xz1_0</span> <span class="o">=</span> <span class="n">augmented_data_0</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">r_xz_eval</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">t_xz_eval</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">theta_eval</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">thetas_eval</span><span class="p">):</span>
            <span class="n">r_xz_eval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">augmented_data_0</span><span class="p">[</span><span class="mi">3</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">t_xz_eval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">augmented_data_0</span><span class="p">[</span><span class="mi">4</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">])</span>

        <span class="n">x_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x_0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">n_additional_thetas</span><span class="p">)])</span>
        <span class="n">r_xz_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">r_xz_0</span><span class="p">]</span> <span class="o">+</span> <span class="n">r_xz_eval</span><span class="p">)</span>
        <span class="n">t_xz0_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">t_xz0_0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">n_additional_thetas</span><span class="p">)])</span>
        <span class="n">t_xz1_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">t_xz1_0</span><span class="p">]</span> <span class="o">+</span> <span class="n">t_xz_eval</span><span class="p">)</span>
        <span class="n">theta0_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">theta0_0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">n_additional_thetas</span><span class="p">)])</span>
        <span class="n">theta1_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">theta1_0</span><span class="p">]</span> <span class="o">+</span> <span class="n">thetas_eval</span><span class="p">)</span>

        <span class="c1"># Parse thetas for theta1 sampling</span>
        <span class="n">theta_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">theta_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">n_samples_per_theta</span> <span class="o">=</span> <span class="mi">1000000</span>

        <span class="n">theta0_types</span><span class="p">,</span> <span class="n">theta0_values</span><span class="p">,</span> <span class="n">this_n_samples</span> <span class="o">=</span> <span class="n">parse_theta</span><span class="p">(</span><span class="n">theta0</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">theta_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theta0_types</span><span class="p">)</span>
        <span class="n">theta_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theta0_values</span><span class="p">)</span>
        <span class="n">n_samples_per_theta</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">this_n_samples</span><span class="p">,</span> <span class="n">n_samples_per_theta</span><span class="p">)</span>

        <span class="n">theta1_types</span><span class="p">,</span> <span class="n">theta1_values</span><span class="p">,</span> <span class="n">this_n_samples</span> <span class="o">=</span> <span class="n">parse_theta</span><span class="p">(</span><span class="n">theta1</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">theta_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theta1_types</span><span class="p">)</span>
        <span class="n">theta_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theta1_values</span><span class="p">)</span>
        <span class="n">n_samples_per_theta</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">this_n_samples</span><span class="p">,</span> <span class="n">n_samples_per_theta</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">additional_theta</span> <span class="ow">in</span> <span class="n">additional_thetas</span><span class="p">:</span>
            <span class="n">additional_theta_types</span><span class="p">,</span> <span class="n">additional_theta_values</span><span class="p">,</span> <span class="n">this_n_samples</span> <span class="o">=</span> <span class="n">parse_theta</span><span class="p">(</span>
                <span class="n">additional_theta</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="p">)</span>
            <span class="n">theta_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">additional_theta_types</span><span class="p">)</span>
            <span class="n">theta_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">additional_theta_values</span><span class="p">)</span>
            <span class="n">n_samples_per_theta</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">this_n_samples</span><span class="p">,</span> <span class="n">n_samples_per_theta</span><span class="p">)</span>

        <span class="c1"># Start for theta1</span>
        <span class="n">x_1</span><span class="p">,</span> <span class="n">augmented_data_1</span><span class="p">,</span> <span class="n">thetas_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_sample</span><span class="p">(</span>
            <span class="n">theta_sets_types</span><span class="o">=</span><span class="n">theta_types</span><span class="p">,</span>
            <span class="n">theta_sets_values</span><span class="o">=</span><span class="n">theta_values</span><span class="p">,</span>
            <span class="n">n_samples_per_theta</span><span class="o">=</span><span class="n">n_samples_per_theta</span><span class="p">,</span>
            <span class="n">augmented_data_definitions</span><span class="o">=</span><span class="n">augmented_data_definitions_1</span><span class="p">,</span>
            <span class="n">sampling_theta_index</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">start_event</span><span class="o">=</span><span class="n">start_event</span><span class="p">,</span>
            <span class="n">end_event</span><span class="o">=</span><span class="n">end_event</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">n_actual_samples</span> <span class="o">+=</span> <span class="n">x_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Analyse theta values from theta1 run</span>
        <span class="n">theta0_1</span> <span class="o">=</span> <span class="n">thetas_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">theta1_1</span> <span class="o">=</span> <span class="n">thetas_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">thetas_eval</span> <span class="o">=</span> <span class="n">thetas_1</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>

        <span class="c1"># Analyse augmented data from theta1 run</span>
        <span class="n">r_xz_1</span> <span class="o">=</span> <span class="n">augmented_data_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">t_xz0_1</span> <span class="o">=</span> <span class="n">augmented_data_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">t_xz1_1</span> <span class="o">=</span> <span class="n">augmented_data_1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">r_xz_eval</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">t_xz_eval</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">theta_eval</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">thetas_eval</span><span class="p">):</span>
            <span class="n">r_xz_eval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">augmented_data_1</span><span class="p">[</span><span class="mi">3</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">t_xz_eval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">augmented_data_1</span><span class="p">[</span><span class="mi">4</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">])</span>

        <span class="n">x_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x_1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">n_additional_thetas</span><span class="p">)])</span>
        <span class="n">r_xz_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">r_xz_1</span><span class="p">]</span> <span class="o">+</span> <span class="n">r_xz_eval</span><span class="p">)</span>
        <span class="n">t_xz0_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">t_xz0_1</span><span class="p">]</span> <span class="o">+</span> <span class="n">t_xz_eval</span><span class="p">)</span>
        <span class="n">t_xz1_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">t_xz1_1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">n_additional_thetas</span><span class="p">)])</span>
        <span class="n">theta0_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">theta0_1</span><span class="p">]</span> <span class="o">+</span> <span class="n">thetas_eval</span><span class="p">)</span>
        <span class="n">theta1_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">theta1_1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">n_additional_thetas</span><span class="p">)])</span>

        <span class="c1"># Combine</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x_0</span><span class="p">,</span> <span class="n">x_1</span><span class="p">])</span>
        <span class="n">r_xz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">r_xz_0</span><span class="p">,</span> <span class="n">r_xz_1</span><span class="p">])</span>
        <span class="n">t_xz0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">t_xz0_0</span><span class="p">,</span> <span class="n">t_xz0_1</span><span class="p">])</span>
        <span class="n">t_xz1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">t_xz1_0</span><span class="p">,</span> <span class="n">t_xz1_1</span><span class="p">])</span>
        <span class="n">theta0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">theta0_0</span><span class="p">,</span> <span class="n">theta0_1</span><span class="p">])</span>
        <span class="n">theta1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">theta1_0</span><span class="p">,</span> <span class="n">theta1_1</span><span class="p">])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">y</span><span class="p">[</span><span class="n">x_0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="k">if</span> <span class="n">n_additional_thetas</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Oversampling: created </span><span class="si">%s</span><span class="s2"> training samples from </span><span class="si">%s</span><span class="s2"> original unweighted events&quot;</span><span class="p">,</span>
                <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">n_actual_samples</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Shuffle</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">r_xz</span><span class="p">,</span> <span class="n">t_xz0</span><span class="p">,</span> <span class="n">t_xz1</span><span class="p">,</span> <span class="n">theta0</span><span class="p">,</span> <span class="n">theta1</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">shuffle</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">r_xz</span><span class="p">,</span> <span class="n">t_xz0</span><span class="p">,</span> <span class="n">t_xz1</span><span class="p">,</span> <span class="n">theta0</span><span class="p">,</span> <span class="n">theta1</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="c1"># y shape</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Save data</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">folder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">folder</span> <span class="o">+</span> <span class="s2">&quot;/theta0_&quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="n">theta0</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">folder</span> <span class="o">+</span> <span class="s2">&quot;/theta1_&quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="n">theta1</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">folder</span> <span class="o">+</span> <span class="s2">&quot;/x_&quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">folder</span> <span class="o">+</span> <span class="s2">&quot;/y_&quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">folder</span> <span class="o">+</span> <span class="s2">&quot;/r_xz_&quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="n">r_xz</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">folder</span> <span class="o">+</span> <span class="s2">&quot;/t_xz0_&quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="n">t_xz0</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">folder</span> <span class="o">+</span> <span class="s2">&quot;/t_xz1_&quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="n">t_xz1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">theta0</span><span class="p">,</span> <span class="n">theta1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">r_xz</span><span class="p">,</span> <span class="n">t_xz0</span><span class="p">,</span> <span class="n">t_xz1</span></div>

<div class="viewcode-block" id="SampleAugmenter.extract_samples_test"><a class="viewcode-back" href="../../madminer.sampling.html#madminer.sampling.SampleAugmenter.extract_samples_test">[docs]</a>    <span class="k">def</span> <span class="nf">extract_samples_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">folder</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">test_split</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">switch_train_test_events</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts evaluation samples `x ~ p(x|theta)` without any augmented data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta : tuple</span>
<span class="sd">            Tuple (type, value) that defines the parameter point or prior over parameter points for the</span>
<span class="sd">            sampling. Pass the output of the functions `constant_benchmark_theta()`, `multiple_benchmark_thetas()`,</span>
<span class="sd">            `constant_morphing_theta()`, `multiple_morphing_thetas()`, or `random_morphing_thetas()`.</span>

<span class="sd">        n_samples : int</span>
<span class="sd">            Total number of events to be drawn.</span>

<span class="sd">        folder : str</span>
<span class="sd">            Path to the folder where the resulting samples should be saved (ndarrays in .npy format).</span>

<span class="sd">        filename : str</span>
<span class="sd">            Filenames for the resulting samples. A prefix such as &#39;x&#39; or &#39;theta0&#39; as well as the extension</span>
<span class="sd">            &#39;.npy&#39; will be added automatically.</span>

<span class="sd">        test_split : float or None, optional</span>
<span class="sd">            Fraction of events reserved for the evaluation sample (that will not be used for any training samples).</span>
<span class="sd">            Default value: 0.5.</span>

<span class="sd">        switch_train_test_events : bool, optional</span>
<span class="sd">            If True, this function generates a test sample from the events normally reserved for training samples.</span>
<span class="sd">            Default value: False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        x : ndarray</span>
<span class="sd">            Observables with shape `(n_samples, n_observables)`. The same information is saved as a file in the given</span>
<span class="sd">            folder.</span>

<span class="sd">        theta : ndarray</span>
<span class="sd">            Parameter points used for sampling with shape `(n_samples, n_parameters)`. The same information is saved as</span>
<span class="sd">            a file in the given folder.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Extracting evaluation sample. Sampling according to </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>

        <span class="n">create_missing_folders</span><span class="p">([</span><span class="n">folder</span><span class="p">])</span>

        <span class="c1"># Thetas</span>
        <span class="n">theta_types</span><span class="p">,</span> <span class="n">theta_values</span><span class="p">,</span> <span class="n">n_samples_per_theta</span> <span class="o">=</span> <span class="n">parse_theta</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">)</span>

        <span class="c1"># Train / test split</span>
        <span class="n">start_event</span><span class="p">,</span> <span class="n">end_event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_train_test_split</span><span class="p">(</span><span class="n">switch_train_test_events</span><span class="p">,</span> <span class="n">test_split</span><span class="p">)</span>

        <span class="c1"># Extract information</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="p">(</span><span class="n">theta</span><span class="p">,)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_sample</span><span class="p">(</span>
            <span class="n">theta_sets_types</span><span class="o">=</span><span class="p">[</span><span class="n">theta_types</span><span class="p">],</span>
            <span class="n">theta_sets_values</span><span class="o">=</span><span class="p">[</span><span class="n">theta_values</span><span class="p">],</span>
            <span class="n">n_samples_per_theta</span><span class="o">=</span><span class="n">n_samples_per_theta</span><span class="p">,</span>
            <span class="n">start_event</span><span class="o">=</span><span class="n">start_event</span><span class="p">,</span>
            <span class="n">end_event</span><span class="o">=</span><span class="n">end_event</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Save data</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">folder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">folder</span> <span class="o">+</span> <span class="s2">&quot;/theta_&quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">folder</span> <span class="o">+</span> <span class="s2">&quot;/x_&quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">theta</span></div>

<div class="viewcode-block" id="SampleAugmenter.extract_cross_sections"><a class="viewcode-back" href="../../madminer.sampling.html#madminer.sampling.SampleAugmenter.extract_cross_sections">[docs]</a>    <span class="k">def</span> <span class="nf">extract_cross_sections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the total cross sections for all specified thetas.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta : tuple</span>
<span class="sd">            Tuple (type, value) that defines the parameter point or prior over parameter points at which the cross</span>
<span class="sd">            section is calculated. Pass the output of the functions `constant_benchmark_theta()`,</span>
<span class="sd">            `multiple_benchmark_thetas()`, `constant_morphing_theta()`, `multiple_morphing_thetas()`, or</span>
<span class="sd">            `random_morphing_thetas()`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        thetas : ndarray</span>
<span class="sd">            Parameter points with shape `(n_thetas, n_parameters)`.</span>

<span class="sd">        xsecs : ndarray</span>
<span class="sd">            Total cross sections in pb with shape `(n_thetas, )`.</span>

<span class="sd">        xsec_uncertainties : ndarray</span>
<span class="sd">            Statistical uncertainties on the total cross sections in pb with shape `(n_thetas, )`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting cross-section calculation&quot;</span><span class="p">)</span>

        <span class="c1"># Total xsecs for benchmarks</span>
        <span class="n">xsecs_benchmarks</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">squared_weight_sum_benchmarks</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">obs</span><span class="p">,</span> <span class="n">weights</span> <span class="ow">in</span> <span class="n">madminer_event_loader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">madminer_filename</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">xsecs_benchmarks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">xsecs_benchmarks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">squared_weight_sum_benchmarks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span> <span class="o">*</span> <span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xsecs_benchmarks</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">squared_weight_sum_benchmarks</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span> <span class="o">*</span> <span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Parse thetas for evaluation</span>
        <span class="n">theta_types</span><span class="p">,</span> <span class="n">theta_values</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">parse_theta</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Loop over thetas</span>
        <span class="n">all_thetas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">all_xsecs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">all_xsec_uncertainties</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">theta_type</span><span class="p">,</span> <span class="n">theta_value</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">theta_types</span><span class="p">,</span> <span class="n">theta_values</span><span class="p">):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">morpher</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">theta_type</span> <span class="o">==</span> <span class="s2">&quot;morphing&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Theta defined through morphing, but no morphing setup has been loaded.&quot;</span><span class="p">)</span>

            <span class="n">theta</span> <span class="o">=</span> <span class="n">get_theta_value</span><span class="p">(</span><span class="n">theta_type</span><span class="p">,</span> <span class="n">theta_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">benchmarks</span><span class="p">)</span>
            <span class="n">theta_matrix</span> <span class="o">=</span> <span class="n">get_theta_benchmark_matrix</span><span class="p">(</span><span class="n">theta_type</span><span class="p">,</span> <span class="n">theta_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">benchmarks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">morpher</span><span class="p">)</span>

            <span class="c1"># Total xsec for this theta</span>
            <span class="n">xsec_theta</span> <span class="o">=</span> <span class="n">theta_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">xsecs_benchmarks</span><span class="p">)</span>
            <span class="n">rms_xsec_theta</span> <span class="o">=</span> <span class="p">((</span><span class="n">theta_matrix</span> <span class="o">*</span> <span class="n">theta_matrix</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">squared_weight_sum_benchmarks</span><span class="p">))</span> <span class="o">**</span> <span class="mf">0.5</span>

            <span class="n">all_thetas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">all_xsecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xsec_theta</span><span class="p">)</span>
            <span class="n">all_xsec_uncertainties</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rms_xsec_theta</span><span class="p">)</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;theta </span><span class="si">%s</span><span class="s2">: xsec = (</span><span class="si">%s</span><span class="s2"> +/- </span><span class="si">%s</span><span class="s2">) pb&quot;</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">xsec_theta</span><span class="p">,</span> <span class="n">rms_xsec_theta</span><span class="p">)</span>

        <span class="c1"># Return</span>
        <span class="n">all_thetas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_thetas</span><span class="p">)</span>
        <span class="n">all_xsecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_xsecs</span><span class="p">)</span>
        <span class="n">all_xsec_uncertainties</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_xsec_uncertainties</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">all_thetas</span><span class="p">,</span> <span class="n">all_xsecs</span><span class="p">,</span> <span class="n">all_xsec_uncertainties</span></div>

<div class="viewcode-block" id="SampleAugmenter.extract_raw_data"><a class="viewcode-back" href="../../madminer.sampling.html#madminer.sampling.SampleAugmenter.extract_raw_data">[docs]</a>    <span class="k">def</span> <span class="nf">extract_raw_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">derivative</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns all events together with the benchmark weights (if theta is None) or weights for a given theta.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta : None or ndarray, optional</span>
<span class="sd">            If None, the function returns the benchmark weights. Otherwise it uses morphing to calculate the weights for</span>
<span class="sd">            this value of theta. Default value: None.</span>

<span class="sd">        derivative : bool, optional</span>
<span class="sd">            If True and if theta is not None, the derivative of the weights with respect to theta are returned. Default</span>
<span class="sd">            value: False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        x : ndarray</span>
<span class="sd">            Observables with shape `(n_unweighted_samples, n_observables)`.</span>

<span class="sd">        weights : ndarray</span>
<span class="sd">            If theta is None and derivative is False, benchmark weights with shape</span>
<span class="sd">            `(n_unweighted_samples, n_benchmarks)` in pb. If theta is not None and derivative is True, the gradient of</span>
<span class="sd">            the weight for the given parameter with respect to theta with shape `(n_unweighted_samples, n_gradients)`</span>
<span class="sd">            in pb. Otherwise, weights for the given parameter theta with shape `(n_unweighted_samples,)` in pb.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">weights_benchmarks</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">madminer_event_loader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">madminer_filename</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">derivative</span><span class="p">:</span>
            <span class="n">dtheta_matrix</span> <span class="o">=</span> <span class="n">get_dtheta_benchmark_matrix</span><span class="p">(</span><span class="s2">&quot;morphing&quot;</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">benchmarks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">morpher</span><span class="p">)</span>

            <span class="n">gradients_theta</span> <span class="o">=</span> <span class="n">dtheta_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">weights_benchmarks</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>  <span class="c1"># (n_gradients, n_samples)</span>
            <span class="n">gradients_theta</span> <span class="o">=</span> <span class="n">gradients_theta</span><span class="o">.</span><span class="n">T</span>

            <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">gradients_theta</span>

        <span class="k">elif</span> <span class="n">theta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">theta_matrix</span> <span class="o">=</span> <span class="n">get_theta_benchmark_matrix</span><span class="p">(</span><span class="s2">&quot;morphing&quot;</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">benchmarks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">morpher</span><span class="p">)</span>

            <span class="n">weights_theta</span> <span class="o">=</span> <span class="n">theta_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">weights_benchmarks</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">weights_theta</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">weights_benchmarks</span></div>

    <span class="k">def</span> <span class="nf">_extract_sample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">theta_sets_types</span><span class="p">,</span>
        <span class="n">theta_sets_values</span><span class="p">,</span>
        <span class="n">n_samples_per_theta</span><span class="p">,</span>
        <span class="n">sampling_theta_index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">augmented_data_definitions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">start_event</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">end_event</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Low-level function for the extraction of information from the event samples. Do not use this function directly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta_sets_types :  list of list of str</span>
<span class="sd">            Each entry can be &#39;benchmark&#39; or &#39;morphing&#39;.</span>

<span class="sd">        theta_sets_values : list of list</span>
<span class="sd">            Each entry is int and labels the benchmark index (if the corresponding</span>
<span class="sd">            theta_sampling_types entry is &#39;benchmark&#39;) or a numpy array with the theta values</span>
<span class="sd">            (of the corresponding theta_sampling_types entry is &#39;morphing&#39;)</span>

<span class="sd">        n_samples_per_theta : int</span>
<span class="sd">            Number of samples to be drawn per entry in theta_sampling_types.</span>

<span class="sd">        augmented_data_definitions : list of tuple or None</span>
<span class="sd">            Each tuple can either be (&#39;ratio&#39;, num_theta, den_theta) or</span>
<span class="sd">            (&#39;score&#39;, theta), where num_theta, den_theta, and theta are indexes marking</span>
<span class="sd">            which of the theta sets defined through thetas_types and thetas_values is</span>
<span class="sd">            used. Default value: None.</span>

<span class="sd">        sampling_theta_index : int</span>
<span class="sd">            Marking the index of the theta set defined through thetas_types and</span>
<span class="sd">            thetas_values that should be used for sampling. Default value: 0.</span>

<span class="sd">        start_event : int</span>
<span class="sd">            Index of first event to consider. Default value: 0.</span>

<span class="sd">        end_event : int or None</span>
<span class="sd">            Index of last event to consider. If None, use the last event. Default value: None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        x :  ndarray</span>
<span class="sd">            Observables.</span>

<span class="sd">        augmented_data : list of ndarray</span>
<span class="sd">            Augmented data.</span>

<span class="sd">        theta : list of ndarray</span>
<span class="sd">            Parameter values.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Starting sample extraction&quot;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">n_samples_per_theta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Requested </span><span class="si">{}</span><span class="s2"> samples per theta!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_samples_per_theta</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">augmented_data_definitions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">augmented_data_definitions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Augmented data requested:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">augmented_data_definition</span> <span class="ow">in</span> <span class="n">augmented_data_definitions</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;  </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">augmented_data_definition</span><span class="p">)</span>

        <span class="c1"># Calculate total xsecs for benchmarks</span>
        <span class="n">xsecs_benchmarks</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">squared_weight_sum_benchmarks</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">n_observables</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">obs</span><span class="p">,</span> <span class="n">weights</span> <span class="ow">in</span> <span class="n">madminer_event_loader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">madminer_filename</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start_event</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end_event</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">xsecs_benchmarks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">xsecs_benchmarks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">squared_weight_sum_benchmarks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span> <span class="o">*</span> <span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xsecs_benchmarks</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">squared_weight_sum_benchmarks</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span> <span class="o">*</span> <span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">n_observables</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Benchmark cross sections [pb]: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">xsecs_benchmarks</span><span class="p">)</span>

        <span class="c1"># Balance thetas</span>
        <span class="n">theta_sets_types</span><span class="p">,</span> <span class="n">theta_sets_values</span> <span class="o">=</span> <span class="n">balance_thetas</span><span class="p">(</span><span class="n">theta_sets_types</span><span class="p">,</span> <span class="n">theta_sets_values</span><span class="p">)</span>

        <span class="c1"># Consistency checks</span>
        <span class="n">n_benchmarks</span> <span class="o">=</span> <span class="n">xsecs_benchmarks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">n_benchmarks</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">benchmarks</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">morphing_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Inconsistent numbers of benchmarks: </span><span class="si">{}</span><span class="s2"> in observations,&quot;</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> in benchmark list&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_benchmarks</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">benchmarks</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">n_benchmarks</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">benchmarks</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n_benchmarks</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">morphing_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Inconsistent numbers of benchmarks: </span><span class="si">{}</span><span class="s2"> in observations, </span><span class="si">{}</span><span class="s2"> in benchmark list, &quot;</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> in morphing matrix&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_benchmarks</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">benchmarks</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">morphing_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">n_observables</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Inconsistent numbers of observables: </span><span class="si">{}</span><span class="s2"> in observations,&quot;</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> in observable list&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_observables</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observables</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="n">n_thetas</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">theta_sets_types</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">n_thetas</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">theta_sets_values</span><span class="p">)</span>
        <span class="c1"># Sets (within each set, all thetas (sampling, numerator, ...) have a constant value)</span>
        <span class="n">n_sets</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">theta_sets_types</span><span class="p">[</span><span class="n">sampling_theta_index</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">theta_types</span><span class="p">,</span> <span class="n">theta_values</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">theta_sets_types</span><span class="p">,</span> <span class="n">theta_sets_values</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">n_sets</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">theta_types</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">theta_values</span><span class="p">)</span>

        <span class="c1"># Number of samples to be drawn</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_samples_per_theta</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
            <span class="n">n_samples_per_theta</span> <span class="o">=</span> <span class="p">[</span><span class="n">n_samples_per_theta</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_sets</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_samples_per_theta</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">n_samples_per_theta</span> <span class="o">=</span> <span class="p">[</span><span class="n">n_samples_per_theta</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">n_sets</span>

        <span class="c1"># Prepare output</span>
        <span class="n">all_x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">all_augmented_data</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">augmented_data_definitions</span><span class="p">]</span>
        <span class="n">all_thetas</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_thetas</span><span class="p">)]</span>
        <span class="n">all_effective_n_samples</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Main loop over thetas</span>
        <span class="k">for</span> <span class="n">i_set</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sets</span><span class="p">):</span>

            <span class="n">n_samples</span> <span class="o">=</span> <span class="n">n_samples_per_theta</span><span class="p">[</span><span class="n">i_set</span><span class="p">]</span>

            <span class="n">theta_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="n">i_set</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">theta_sets_types</span><span class="p">]</span>
            <span class="n">theta_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="n">i_set</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">theta_sets_values</span><span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">morpher</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s2">&quot;morphing&quot;</span> <span class="ow">in</span> <span class="n">theta_types</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Theta defined through morphing, but no morphing setup has been loaded.&quot;</span><span class="p">)</span>

            <span class="c1"># Parse thetas and calculate the w_c(theta) for them</span>
            <span class="n">thetas</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">theta_matrices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">theta_gradient_matrices</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Drawing </span><span class="si">%s</span><span class="s2"> events for the following thetas:&quot;</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i_theta</span><span class="p">,</span> <span class="p">(</span><span class="n">theta_type</span><span class="p">,</span> <span class="n">theta_value</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">theta_types</span><span class="p">,</span> <span class="n">theta_values</span><span class="p">)):</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">get_theta_value</span><span class="p">(</span><span class="n">theta_type</span><span class="p">,</span> <span class="n">theta_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">benchmarks</span><span class="p">)</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">theta</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
                <span class="n">thetas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

                <span class="n">theta_matrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">get_theta_benchmark_matrix</span><span class="p">(</span><span class="n">theta_type</span><span class="p">,</span> <span class="n">theta_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">benchmarks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">morpher</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">theta_gradient_matrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">get_dtheta_benchmark_matrix</span><span class="p">(</span><span class="n">theta_type</span><span class="p">,</span> <span class="n">theta_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">benchmarks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">morpher</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;  theta </span><span class="si">%s</span><span class="s2"> = </span><span class="si">%s%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">i_theta</span><span class="p">,</span> <span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="s2">&quot; (sampling)&quot;</span> <span class="k">if</span> <span class="n">i_theta</span> <span class="o">==</span> <span class="n">sampling_theta_index</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                <span class="p">)</span>

            <span class="n">sampling_theta_matrix</span> <span class="o">=</span> <span class="n">theta_matrices</span><span class="p">[</span><span class="n">sampling_theta_index</span><span class="p">]</span>

            <span class="c1"># Total xsec for sampling theta</span>
            <span class="n">xsec_sampling_theta</span> <span class="o">=</span> <span class="n">sampling_theta_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">xsecs_benchmarks</span><span class="p">)</span>
            <span class="n">rms_xsec_sampling_theta</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">sampling_theta_matrix</span> <span class="o">*</span> <span class="n">sampling_theta_matrix</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">squared_weight_sum_benchmarks</span><span class="p">)</span>
            <span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>

            <span class="k">if</span> <span class="n">rms_xsec_sampling_theta</span> <span class="o">&gt;</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">xsec_sampling_theta</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Warning: large statistical uncertainty on the total cross section for theta = </span><span class="si">%s</span><span class="s2">: &quot;</span>
                    <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2"> +/- </span><span class="si">%s</span><span class="s2">) pb&quot;</span><span class="p">,</span>
                    <span class="n">thetas</span><span class="p">[</span><span class="n">sampling_theta_index</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">xsec_sampling_theta</span><span class="p">,</span>
                    <span class="n">rms_xsec_sampling_theta</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="c1"># Prepare output</span>
            <span class="n">samples_done</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
            <span class="n">samples_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">n_observables</span><span class="p">))</span>
            <span class="n">samples_augmented_data</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">definition</span> <span class="ow">in</span> <span class="n">augmented_data_definitions</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">definition</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;ratio&quot;</span><span class="p">:</span>
                    <span class="n">samples_augmented_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
                <span class="k">elif</span> <span class="n">definition</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;score&quot;</span><span class="p">:</span>
                    <span class="n">samples_augmented_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_parameters</span><span class="p">)))</span>

            <span class="n">largest_weight</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="c1"># Main sampling loop</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">samples_done</span><span class="p">):</span>

                <span class="c1"># Draw random numbers in [0, 1]</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>  <span class="c1"># Shape: (n_samples,)</span>

                <span class="c1"># Loop over weighted events</span>
                <span class="n">cumulative_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">])</span>

                <span class="k">for</span> <span class="n">x_batch</span><span class="p">,</span> <span class="n">weights_benchmarks_batch</span> <span class="ow">in</span> <span class="n">madminer_event_loader</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">madminer_filename</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start_event</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end_event</span>
                <span class="p">):</span>
                    <span class="c1"># Evaluate p(x | sampling theta)</span>
                    <span class="n">weights_theta</span> <span class="o">=</span> <span class="n">sampling_theta_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">weights_benchmarks_batch</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>  <span class="c1"># Shape (n_batch_size,)</span>
                    <span class="n">p_theta</span> <span class="o">=</span> <span class="n">weights_theta</span> <span class="o">/</span> <span class="n">xsec_sampling_theta</span>  <span class="c1"># Shape: (n_batch_size,)</span>

                    <span class="c1"># Handle negative weights (should be rare)</span>
                    <span class="n">n_negative_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p_theta</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">n_negative_weights</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                            <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> negative weights (</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">n_negative_weights</span><span class="p">,</span> <span class="n">n_negative_weights</span> <span class="o">/</span> <span class="n">p_theta</span><span class="o">.</span><span class="n">size</span>
                        <span class="p">)</span>
                    <span class="n">p_theta</span><span class="p">[</span><span class="n">p_theta</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

                    <span class="c1"># Remember largest weights (to calculate effective number of samples)</span>
                    <span class="n">largest_weight</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">largest_weight</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">p_theta</span><span class="p">))</span>

                    <span class="c1"># Calculate cumulative p (summing up all events until here)</span>
                    <span class="n">cumulative_p</span> <span class="o">=</span> <span class="n">cumulative_p</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">p_theta</span><span class="p">)</span>  <span class="c1"># Shape: (n_batch_size,)</span>

                    <span class="c1"># When cumulative_p hits u, we store the events</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">cumulative_p</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    <span class="c1"># Shape: (n_samples,), values: [0, ..., n_batch_size]</span>

                    <span class="n">found_now</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">samples_done</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">indices</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cumulative_p</span><span class="p">))</span>  <span class="c1"># Shape: (n_samples,)</span>
                    <span class="n">samples_x</span><span class="p">[</span><span class="n">found_now</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_batch</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">found_now</span><span class="p">]]</span>
                    <span class="n">samples_done</span><span class="p">[</span><span class="n">found_now</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="c1"># Extract augmented data</span>
                    <span class="n">relevant_augmented_data</span> <span class="o">=</span> <span class="n">extract_augmented_data</span><span class="p">(</span>
                        <span class="n">augmented_data_definitions</span><span class="p">,</span>
                        <span class="n">weights_benchmarks_batch</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">found_now</span><span class="p">],</span> <span class="p">:],</span>
                        <span class="n">xsecs_benchmarks</span><span class="p">,</span>
                        <span class="n">theta_matrices</span><span class="p">,</span>
                        <span class="n">theta_gradient_matrices</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">this_relevant_augmented_data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">relevant_augmented_data</span><span class="p">):</span>
                        <span class="n">samples_augmented_data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">found_now</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_relevant_augmented_data</span>

                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">samples_done</span><span class="p">):</span>
                        <span class="k">break</span>

                <span class="c1"># Cross-check cumulative probabilities at end</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;  Cumulative probability (should be close to 1): </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">cumulative_p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

                <span class="c1"># Check that we got &#39;em all, otherwise repeat</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">samples_done</span><span class="p">):</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="s2">&quot;  After full pass through event files, </span><span class="si">{}</span><span class="s2"> / </span><span class="si">{}</span><span class="s2"> samples not found, u = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">samples_done</span><span class="p">)),</span> <span class="n">samples_done</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">u</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">samples_done</span><span class="p">)]</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

            <span class="n">all_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">samples_x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">theta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">thetas</span><span class="p">):</span>
                <span class="n">all_thetas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">this_samples_augmented_data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">samples_augmented_data</span><span class="p">):</span>
                <span class="n">all_augmented_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_samples_augmented_data</span><span class="p">)</span>
            <span class="n">all_effective_n_samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mf">1.0e-12</span><span class="p">,</span> <span class="n">largest_weight</span><span class="p">))</span>

        <span class="c1"># Combine and return results</span>
        <span class="n">all_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">all_x</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_thetas</span><span class="p">):</span>
            <span class="n">all_thetas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">all_thetas</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_augmented_data</span><span class="p">)):</span>
            <span class="n">all_augmented_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">all_augmented_data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">all_effective_n_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_effective_n_samples</span><span class="p">)</span>

        <span class="c1"># Report effective number of samples</span>
        <span class="k">if</span> <span class="n">n_sets</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Effective number of samples: mean </span><span class="si">%s</span><span class="s2">, with individual thetas ranging from </span><span class="si">%s</span><span class="s2"> to </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">all_effective_n_samples</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">all_effective_n_samples</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">all_effective_n_samples</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Effective number of samples for all thetas: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">all_effective_n_samples</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Effective number of samples: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">all_effective_n_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">all_x</span><span class="p">,</span> <span class="n">all_augmented_data</span><span class="p">,</span> <span class="n">all_thetas</span>

    <span class="k">def</span> <span class="nf">_train_test_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">test_split</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the start and end event for train samples (train = True) or test samples (train = False).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train : bool</span>
<span class="sd">            True if training data is generated, False if test data is generated.</span>

<span class="sd">        test_split : float</span>
<span class="sd">            Fraction of events reserved for testing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        start_event : int</span>
<span class="sd">            Index of the first unweighted event to consider.</span>

<span class="sd">        end_event : int</span>
<span class="sd">            Index of the last unweighted event to consider.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">train</span><span class="p">:</span>
            <span class="n">start_event</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="n">test_split</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">test_split</span> <span class="o">&lt;=</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">test_split</span> <span class="o">&gt;=</span> <span class="mf">1.0</span><span class="p">:</span>
                <span class="n">end_event</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">end_event</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">test_split</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">end_event</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">end_event</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Irregular train / test split: sample </span><span class="si">{}</span><span class="s2"> / </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">end_event</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">test_split</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">test_split</span> <span class="o">&lt;=</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">test_split</span> <span class="o">&gt;=</span> <span class="mf">1.0</span><span class="p">:</span>
                <span class="n">start_event</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">start_event</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">test_split</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">start_event</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">start_event</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Irregular train / test split: sample </span><span class="si">{}</span><span class="s2"> / </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">start_event</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">)</span>

            <span class="n">end_event</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">start_event</span><span class="p">,</span> <span class="n">end_event</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">MadMiner</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../madminer.core.html">madminer.core module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../madminer.delphes.html">madminer.delphes module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../madminer.fisherinformation.html">madminer.fisherinformation module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../madminer.ml.html">madminer.ml module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../madminer.morphing.html">madminer.morphing module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../madminer.plotting.html">madminer.plotting module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../madminer.sampling.html">madminer.sampling module</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;Johann Brehmer, Felix Kling, and Kyle Cranmer 2018.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>